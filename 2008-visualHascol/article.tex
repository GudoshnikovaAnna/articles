\documentclass[a5paper]{article}
\usepackage[a5paper, top=17mm, bottom=17mm, left=17mm, right=17mm]{geometry}
\usepackage[cp1251]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[colorlinks,filecolor=blue,citecolor=green,unicode,pdftex]{hyperref}
\usepackage{cmap}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{literat}
\usepackage{indentfirst}

\sloppy
\pagestyle{empty}

\title{Использование визуального моделирования для проектирования аппаратного обеспечения}

\author{Ю.В.Литвинов\\yurii.litvinov@at-software.com}
\date{}
\begin{document}

\maketitle
\thispagestyle{empty}

\begin{quote}
\small\noindent
В статье рассматривается вопрос об использовании языков визуального моделирования для разработки аппаратного обеспечения. Для этой цели было создано множество различных языков и методологий, однако далеко не все из них стали популярны, несмотря на существенные преимущества использования визуальных моделей для спецификации аппаратных устройств. В статье рассматриваются некоторые из существующих подходов, а также предлагается новый язык визуального моделирования.

% \renewcommand{\thefootnote}{}
% \footnote{\small{\copyright~Ю.В.Литвинов, 2008.}}
% \renewcommand{\thefootnote}{\arabic{footnote}}
% \setcounter{footnote}{0}
\end{quote}

\section*{Введение}

По мере того, как различные встроенные устройства набирают популярность, задача проектирования аппаратного обеспечения становится всё более актуальной. Однако, задача эта до сих пор остаётся сложной и трудоёмкой, и немаловажную роль в этом играет отсутствие качественных средств разработки. В 80-х годах двадцатого века появились языки Verilog и VHDL, которые и по сей день остаются фактическим стандартом в деле разработки аппаратного обеспечения. Эти языки позволяют описать устройство аналогично коду обычной программы, их синтаксис похож на синтаксис традиционных языков программирования. Verilog похож на C, VHDL --- на Аду, причём в обоих случаях это было сделано преднамеренно, чтобы переиспользовать проверенные концепции языков программирования и чтобы разработчики не испытывали затруднений при переобучении. Эти языки позволяют синтезировать описание разрабатываемого аппаратного обеспечения, пригодное для производства, или произвести эмуляцию.

Инструментальная поддержка разработки аппаратного обеспечения до сих пор сильно отстаёт от инструментальной поддержки разработки ПО. Одним из путей преодоления этого отставания стала разработка языков более высокого уровня, чем VHDL, и попытка применения к разработке аппаратного обеспечения концепций из мира ПО, например, приёмов объектно-ориентированного программирования.

Особенно интересным способом снизить затраты на разработку аппаратного обеспечения является применение визуальных моделей. Визуальные методы разработки здесь даже более применимы, чем в области разработки ПО, поскольку аппаратное обеспечение традиционно описывалось различными чертежами и схемами. Однако же, в силу высокой (и постоянно растущей) сложности аппаратного обеспечения, средство визуального моделирования не может быть просто редактором электронных схем, а должно само поддерживать высокоуровневые концепции. Ещё одним важным требованием, накладываемым на такое средство, является исполнимость модели. Средство должно иметь возможность синтезировать описание устройства в виде, пригодном для использования промышленным оборудованием при производстве, и генерировать эмулятор устройства, позволяющий вести отладку, тестирование и оценку производительности, не прибегая к созданию дорогостоящего прототипа. Все эти сложности задерживают рост популярности визуальных технологий.

В этой статье будет представлен краткий обзор подходов к использованию технологий визуального моделирования для разработки аппаратного обеспечения, а также предложен новый язык визуального моделирования. Предлагаемый подход базируется на схеме, достаточно широко распространённой среди текстовых языков разработки аппаратного обеспечения --- по коду на языке высокого уровня синтезируется не непосредственно физическое описание устройства, а код на языке более низкого уровня. Описанный в этой статье визуальный язык использует в качестве базового высокоуровневый язык системы CoolKit~\cite{coolKit1}~\cite{coolKit2} --- конструкции его графической нотации простым способом отображаются в конструкции текстового языка. Текстовый язык, в свою очередь, отображается в VHDL.

% TODO: убедиться, что в статье рассказано, что такое CoolKit по отношению к VHDL

\section{Обзор существующих подходов}

\subsection{UML 2}

Стандартом де-факто визуального моделирования программного обеспечения является на данный момент Unified Modelling Language (UML), формально определённый группой OMG (Object Management Group) в 1996 году и активно развивающийся по сей день. В силу высокой универсальности и удобных механизмов расширения язык UML может быть использован практически во всех областях деятельности, связанной с разработкой программного обеспечения, в том числе и для визуального моделирования аппаратного обеспечения.

В первых версиях языка UML отсутствовали удобные средства представления сложных структурированных объектов, поэтому моделировать аппаратную систему непосредственно на UML было весьма затруднительно. Для решения этой проблемы был создан профиль UML, названный UML-RT~\cite{umlRt}, предназначавшийся для моделирования систем реального времени. Впоследствии конструкции из этого профиля были включены в стандарт UML, став, по мнению авторов, одной из наиболее важных возможностей моделирования, добавленных в UML 2.0~\cite{Uml}.

Основным средством моделирования аппаратных и программно-аппаратных систем в UML 2 являются структурированные классификаторы. Структурированный классификатор содержит внутри себя набор частей, соединённых между собой соединителями. Экземпляр структурированного классификатора для каждой из частей содержит в себе соответствующий объект (или набор объектов). Объект-часть может принадлежать только одному структурированному объекту. Соединитель определяет отношение между объектами, входящими в состав одного и того же структурированного объекта. 

Взаимодействие структурированных классификаторов с внешним миром и внутренними частями происходит исключительно через порты. Порт --- это точка взаимодействия со строго определённым интерфейсом. Один структурированный классификатор может иметь несколько портов, а также имеет возможность определить, на какой из портов пришёл запрос. Запросы, приходящие на порты, могут быть обработаны непосредственно объектом -- хозяином порта или переданы на порт какой-либо его части. Каждый порт имеет набор предоставляемых им интерфейсов и набор интерфейсов, требуемых от внешней среды. Пример нотации приведён на рисунке~\ref{camcoder}.

\begin{figure} [ht]
  \begin{center}
    \includegraphics[width=7cm, keepaspectratio=true]{camcoder.pdf}
    \caption{Пример нотации портов и интерфейсов}
    \label{camcoder}
  \end{center}
\end{figure}

Пример структурированного классификатора с внутренней структурой приведён на рисунке~\ref{compositeStructure}

\begin{figure} [ht]
  \begin{center}
    \includegraphics[width=6cm, keepaspectratio=true]{compositeStructure.pdf}
    \caption{Классификатор с внутренней структурой}
    \label{compositeStructure}
  \end{center}
\end{figure}

Для задания внутреннего поведения элементов системы обычно используется диаграмма конечных автоматов. Каждый структурированный классификатор может иметь связанный с ним конечный автомат, который описывает реакцию на события, приходящие на его порты. Пример диаграммы конечных автоматов приведён на рисунке~\ref{stateMachine}

\begin{figure} [ht]
  \begin{center}
    \includegraphics[width=8cm, keepaspectratio=true]{stateMachine.pdf}
    \caption{Диаграмма состояний}
    \label{stateMachine}
  \end{center}
\end{figure}

\subsection{Методология на основе UML}

Важным достоинством языка UML является то, что он достаточно абстрактный и не зависит от того, каким образом будут исполняться модели. Поэтому при разработке сложной программно-аппаратной системы можно отложить решение о том, какие части системы будут реализованы программно, а какие --- аппаратно, до самого конца разработки. Пример методологии, использующей это свойство, изложен в статье~\cite{fromUmlToHdl}. Процесс разработки программно-аппаратной системы в этой методологии состоит из следующих шагов:

\begin{enumerate}
  \item Описание высокоуровневой модели разрабатываемой системы средствами UML --- диаграммы компонентов, случаев использования, классов, состояний и т.д.
  \item Автоматизированная генерация программных и аппаратных компонент системы по спецификациям, полученным на шаге 1. Для автоматической генерации кода используются только диаграммы состояний.
    \begin{enumerate}
      \item Диаграммы состояний системы сохраняются в формате XMI (XML Metadata Interchange) --- стандартном формате описания UML-диаграмм, базирующемся 
            на XML. Этот формат обычно используется для обмена диаграммами между различными инструментами моделирования, в данной методологии
            XMI-спецификация используется как входная информация для генератора.
      \item XMI разбирается XML-анализатором.
      \item По XMI и шаблонам, описывающим проекции UML в язык описания аппаратного обеспечения, генерируется код.
    \end{enumerate}
\end{enumerate}

\subsection{Паттерны проектирования аппаратного обеспечения}

Поскольку UML --- объектно-ориентированный язык, который может быть использован для разработки аппаратного обеспечения, было бы естественно попробовать применить паттерны объектно-ориентированного проектирования, уже существующие в области программного обеспечения, для разработки аппаратных частей систем. Например, в статьях~\cite{damasevicius1},~\cite{damasevicius2} уточняется понятие “паттерн” для аппаратного обеспечения --- паттерн понимается авторами как описание процесса проектирования уровня системы вместе с инструментальными средствами поддержки этого процесса или автоматической генерации (этим видение авторов отличается от “традиционных” паттернов, которые просто описывают какие-либо проверенные на опыте удачные архитектурные решения). Проектирование уровня системы предполагает проектирование с использованием сторонних компонент в качестве базовых строительных блоков. Авторы также выделяют “микропаттерны”, или операции, например, расширение --- добавление новых портов в интерфейс компонента, или логическая композиция --- получение интерфейса компонента посредством объединения нескольких базовых интерфейсов.

\begin{figure} [ht]
  \begin{center}
    \includegraphics[width=5cm, keepaspectratio=true]{wrapper.pdf}
    \caption{Паттерн Wrapper}
    \label{wrapper}
  \end{center}
\end{figure}

В качестве примера полноценного паттерна проектирования аппаратного обеспечения можно рассмотреть паттерн Обёртка (Wrapper) --- он изображён на рисунке~\ref{wrapper}. Как и в случае с одноимённым паттерном программного обеспечения, он предназначается для адаптации существующего компонента к требованиям окружения.

Прерывистой линией на рисунке показана реализация --- архитектура IPModel реализует функциональность сущности IP (Intellectual Property, существующий компонент, к которому создаётся обёртка), архитектура WrapperModel реализует функциональность сущности Wrapper и содержит сущность IP, которую использует для реализации запросов. Сущность Wrapper наследует все порты сущности IP и определяет свои собственные. Паттерн может быть вложенным, можно применить несколько обёрток к одному компоненту, однако надлежит помнить о дополнительном пространстве и времени, которые потребуются для работы (для ПО это далеко не так существенно, как для аппаратного обеспечения).

Поскольку паттерн достаточно формально определён, становится возможной его автоматическая генерация. Авторы предлагают использовать для генерации паттерна метапрограммирование. Генератор, который пишется вручную, может создать требуемую обёртку для любого компонента.

\subsection{Профиль UML для SystemC}

Язык UML обычно не используется при разработке аппаратного обеспечения напрямую, для него стандартным образом определяются расширения, называемые профилями. Профиль --- средство для расширения языка UML и приспособления его для нужд предметной области. Профиль представляет из себя набор стереотипов --- расширений синтаксиса или семантики стандартных сущностей UML. Стереотипы могут также определять дополнительные ограничения на сущности. Пример профиля, созданного для разработки аппаратного обеспечения, представлен в статье~\cite{riccobene} --- профиль UML для языка SystemC.

SystemC~\cite{arnout} --- язык проектирования уровня системы, основанный на C++ и поддерживаемый группой крупных компаний. Система в SystemC состоит из модулей, каждый модуль может содержать переменные, порты для взаимодействия с окружением и процессы, реализующие функциональность модуля. Процессы исполняются параллельно и могут реагировать на события. Связь между модулями осуществляется с помощью портов, которые предоставляют модулям доступ к каналам. Каналы бывают примитивными и иерархическими: иерархический канал --- тоже модуль, имеет свои процессы и может иметь доступ к другим каналам.

Профиль UML для SystemC логически разделён на 3 части:

\begin{enumerate}
   \item Структуры и коммуникации --- определяет стереотипы для базовых строительных блоков SystemC. Эти стереотипы представляют модули, порты, 
         интерфейсы и каналы, и используются на различных диаграммах UML, например, на диаграммах классов и диаграммах композитных структур.
   \item Поведение и синхронизация --- определяет стереотипы для спецификации поведения процессов SystemC. Эти стереотипы используются в диаграммах 
         состояний UML.
   \item Типы данных --- представляет типы данных SystemC.
\end{enumerate}

Модуль SystemC в предлагаемой авторами нотации выглядит так, как изображено на рисунке~\ref{systemCModule}, диаграмма композитных структур изображена на рисунке~\ref{systemCComposite}, и наконец, пример диаграммы состояний, специфицирующей поведение процесса, изображён на рисунке~\ref{systemCStateMachine}

\begin{figure} [hb]
  \begin{center}
    \includegraphics[width=6cm, keepaspectratio=true]{SystemCmodule.pdf}
    \caption{Модуль в нотации SystemC}
    \label{systemCModule}
  \end{center}
\end{figure}

\begin{figure} [ht] 
  \begin{center}
    \includegraphics[width=6cm, keepaspectratio=true]{SystemCcomposite.pdf}
    \caption{Диаграмма композитных структур SystemC}
    \label{systemCComposite}
  \end{center}
\end{figure}

\begin{figure} [ht] 
  \begin{center}
    \includegraphics[width=5cm, keepaspectratio=true]{SystemCstateMachine.pdf}
    \caption{Диаграмма состояний SystemC}
    \label{systemCStateMachine}
  \end{center}
\end{figure}

\subsection{Обзор системы CoolKit}

Язык системы CoolKit~\cite{coolKit1},~\cite{coolKit2} --- язык высокого уровня, описывающий систему в терминах исполняемых параллельно обработчиков сигналов. Обработчики объединены в процессы --- сущности, инкапсулирующие в себе ресурсы (данные), обработчики сигналов и другие процессы, и имеющие входы и выходы. Обработчик представляет из себя последовательность однотактовых шагов, выполняющихся, если некоторые условия (получение сообщения, состояние ресурсов процесса) истинны. Обработчики могут начинать своё исполнение на каждом такте, на котором выполнены условия его старта, вне зависимости от того, выполняются они уже или нет.

Пример описания процесса:

\begin{verbatim}
process DynamicArbiter =
begin
  in one(uint(2), uint(8));
  in two(uint(2), uint(8));
  out res(uint(8));
  
  group {
    -- что делать, если пришли оба сигнала:
    -- условия на принимаемые сигналы определяют готовность
    -- принятия данных из каждого входа в отдельности
    one(prio1, data1) and prio1 >= prio2,
    two(prio2, data2) and prio1 < prio2
    {
      send res (if prio1 >= prio2 then data1 else data2 fi)
    }
    -- если пришел только один сигнал --- случай попроще
    -- подчеркивание вместо имени параметра означает, что
    -- нас данный параметр не интересует и пользоваться им
    -- мы не будем
    one(_, ddata) {send res (ddata)}
    two(_, ddata) {send res (ddata)}
  }
end
\end{verbatim}

Процесс имеет два входа (one, two) с двумя параметрами и выход res, возвращающий значение типа uint(8). Конструкцией group три обработчика объединены в группу, перед фигурными скобками записано условие, при истинности которого обработчик начнёт работу, внутри фигурных скобок --- тело обработчика. В условиях могут участвовать проверки наличия данных на входах, логические выражения с участием входных данных и локальных данных процесса. Конструкция send в теле обработчика --- посылка сигнала на указанный выход. Входы и выходы могут также иметь несколько портов, каждый порт может быть связан с очередью сообщений. Например, \begin{verbatim}in InputData (int(16))[A[1], B];\end{verbatim} определяет вход с одним параметром и двумя портами, при этом размер очереди порта A --- 1. Размер очереди порта B --- 0.

Для поддержки структурной декомпозиции процессов в язык был введён структурный уровень. Структурные конструкции позволяют отображать входы объемлющего процесса на порты входов вложенного, и выходы вложенного процесса на выходы объемлющего или входы вложенного, позволяя таким образом структурно декомпозировать процессы на наборы взаимодействующих вложенных подпроцессов.

Каждый процесс имеет свой тип, задаваемый явно или неявно. Тип процесса --- перечень его входов и выходов с указанием типов их аргументов. Над типами процессов определено отношение структурного сабтайпинга --- неформально говоря, процесс A имеет тип, являющийся подтипом типа процесса B, если A можно везде использовать вместо B. Тип процесса по умолчанию получается из спецификации процесса, тип можно указать и явно, это используется, например, для описания свойств параметров функторов.

Функтор --- это процесс, параметризованный другим процессом. Например,

\begin{verbatim}
process Wrapper (P: Proc) =
begin
  process X = P;
  process Y = P;
  ...
end
\end{verbatim}

Процесс Wrapper параметризован процессом P типа Proc. Применение функтора выглядит так:

\begin{verbatim}
process W = Wrapper(aProc);
\end{verbatim}

\subsection{Выводы}

Как видно из обзора, предпринимается довольно много попыток использовать визуальные языки для разработки аппаратного обеспечения. При этом основное внимание уделяется языку UML, видимо, в силу его широкой распространённости. Понятность визуального языка является особенно важным для языков разработки аппаратного обеспечения качеством, поскольку визуальный язык, скорее всего, будет использоваться для общения между специалистами по программному и аппаратному обеспечению. Хочется также отметить, что использование языка обычно влечёт за собой использование соответствующей методологии разработки, например, использование UML обычно влечёт применение методов объектно-ориентированного программирования.

Существующие визуальные языки пытаются целиком специфицировать систему графическими средствами, в результате диаграммы получаются сложнее для восприятия, чем текстовое представление. Кроме того, генерировать низкоуровневый код непосредственно по моделям высокого уровня абстракции оказывается достаточно сложно, поэтому существующие средства разработки либо фокусируют внимание на поведенческих аспектах систем, генерируя код по автоматным моделям, либо используют какой-либо язык высокого уровня в качестве промежуточного. В случае использования промежуточного языка возникает проблема согласования конструкций визуального языка (если в качестве визуального языка берётся какой-либо универсальный язык, например, UML), и текстового языка. Возможно, использование UML или его профилей в этом случае не всегда оправданно.

Предлагаемое в этой статье решение будет использовать подход с использованием промежуточного языка, в качестве которого используется язык системы CoolKit. При этом основное внимание будет уделяться визуализации структуры системы, а её поведение будет описываться непосредственно на текстовом языке внутри модели. Это позволит избежать чрезмерной сложности графической спецификации поведения элементов системы. Наибольший интерес для визуализации представляют конструкции структурного уровня языка CoolKit, в частности отображения портов и структурные взаимосвязи процессов, в том числе функторы. 

\section{Графическая нотация}

Графические конструкции предлагаемого языка довольно просто транслируются в текстовое представление на языке системы CoolKit. Основные принципы, в соответствии с которыми разрабатывалась нотация, таковы:

\begin{itemize}
  \item Модель должна быть исполняемой, то есть позволять синтезировать код на языке системы CoolKit без необходимости ручной корректировки 
        результатов. Традиционно по визуальной модели генерируется скелет программы, который надо вручную доводить до исполнимого состояния, при этом 
        возникают проблемы с синхронизацией модели и кода, к тому же такой подход как правило не отменяет необходимости сопровождать сгенерированный 
        код. Пригодная для промышленного использования технология должна позволять программисту получать готовую низкоуровневую спецификацию системы 
        или эмулятор, действуя в одной среде разработки и, желательно, с одним представлением системы.

  \item Графическими примитивами должны быть представлены только те элементы программы, которые наиболее выгодно представлять графически. Остальная 
        необходимая для синтеза информация должна быть представлена на визуальной модели в текстовой форме. Опыт показывает, например, что на данный 
        момент нарисовать диаграмму состояний, которая описывает реализацию функциональности какого-либо метода, оказывается сложнее, чем написать код
        на подходящем текстовом языке, который реализует эту функциональность. С этим можно бороться либо совершенствуя средства рисования диаграмм,
        либо дав возможность пользователю использовать текстовый язык для описания трудновизуализируемых частей системы. На данный момент мы пошли по 
        второму пути, однако, по мере развития инструментальных средств возможно расширение языка новыми графическими конструкциями.

  \item Нотация разрабатывалась для использования внутри среды разработки, поэтому некоторые её элементы могут быть неудобны для представления на 
        бумаге.
\end{itemize}

Для визуализации языка CoolKit плохо подходит непосредственно UML и даже профиль для UML --- целевой язык не является строго говоря объектно-ориентированным, к тому же обладает рядом особенностей, которые плохо или неудобно выражаются в терминах UML. И главная причина, почему мы не используем UML напрямую --- наибольшая наглядность визуализации может быть достигнута при применении специально созданной для этого нотации. Аргумент за использование строго определённого профиля UML по сути только один --- стандартизация, что даёт возможность, во-первых, быстро, просто и однозначно определить профиль, во-вторых, использовать уже существующие средства, поддерживающие UML 2.0 для реализации языка. Для нас это не играет серьёзной роли, поскольку нотация создавалась для использования в рамках технологии, делающей разработку графического редактора и генератора для поддержки языка низкозатратной, да и сам целевой текстовый язык ещё недостаточно распространён, и наличие ещё одной малораспространённой технологии, которая облегчает программирование на нём, не скажется серьёзно на затратах на внедрение.

Предлагаемый графический язык, хотя и не является профилем UML, сформулирован с активным использованием метамодели UML. Для формализации языка используется метамоделирование --- синтаксис графических конструкций языка описан с помощью диаграмм UML. Сам язык UML специфицирован аналогичным образом. Метамодель языка построена на метамодели ядра и некоторых диаграмм UML, таким образом, язык лишь незначительно отличается от UML и его синтаксис и семантика интуитивно понятны специалистам, занимающимся визуальным моделированием. Кроме того, переиспользование метамодели UML позволило сэкономить массу усилий при формализации языка. Одним из полученных результатов стало понимание того, что формализация предметно-ориентированных языков программирования может быть существенно упрощена благодаря переиспользованию некоей стандартной метамодели, например UML.

Для спецификации системы в нашем языке используется два вида диаграмм --- диаграмма типов процессов и диаграмма отображения портов. Заметим, что мы избежали необходимости использовать диаграммы автоматов для описания поведения системы --- эту роль выполняют текстовые блоки на целевом языке. Диаграмма типов процессов базируется на диаграмме классов UML, а диаграмма отображения портов --- на диаграмме композитных структур.

\subsection{Диаграмма типов процессов}

Диаграмма типов процессов используется для задания основных структурных свойств и отношений процессов, составляющих пакет или приложение. На диаграмме изображаются сами процессы, их входы и выходы, отношения вложенности, отношения генерализации, и функторы. Заметим, что на этой диаграмме не рисуются обработчики событий, и могут не рисоваться ресурсы процесса (список ресурсов процесса может быть неполным, из того, что ресурс не изображён на диаграмме, нельзя делать вывод, что он не описан в процессе). Некоторые вложенные процессы тоже могут быть опущены на этой диаграмме, если это не повлияет на корректность модели.

Часть метамодели диаграммы представлена на рисунке~\ref{processDiagramMetamodel}

\begin{figure} [ht]
  \begin{center}
    \includegraphics[width=9cm, keepaspectratio=true]{CoolKitVLmetamodel1.pdf}
    \caption{Синтаксис диаграммы типов процессов}
    \label{processDiagramMetamodel}
  \end{center}
\end{figure}

Пример изображения вложенных процессов представлен на рисунке~\ref{nestedProcesses}

\begin{figure} [ht]
  \begin{center}
    \includegraphics[width=6cm, keepaspectratio=true]{CoolKitVLmetamodel5.pdf}
    \caption{Нотация процессов}
    \label{nestedProcesses}
  \end{center}
\end{figure}

Как видно из примера, нотация перечисляет ресурсы, входы и выходы процессов в таком виде, в каком они были в языке системы CoolKit. По-настоящему графически здессь изображаются только отношения использования одного процесса внутри другого или вложенности процессов (т.е. когда один процесс описан непосредственно внутри другого). Заметим, что вложенный процесс может не иметь имени --- тогда оно просто не отображается на диаграмме. Поскольку вложенные или используемые процессы являются деталями реализации объемлющего процесса, они могут не рисоваться на диаграмме. Существенную выгоду от использования этого типа диаграммы можно получить при использовании в программе функторов. Пример нотации объявления функторов приведён на рисунке~\ref{functors}

\begin{figure} [ht]
  \begin{center}
    \includegraphics[width=6cm, keepaspectratio=true]{CoolKitVLmetamodel6.pdf}
    \caption{Нотация функторов}
    \label{functors}
  \end{center}
\end{figure}

В частности, из-за особенности нотации, которую можно видеть на примере, было принято решение не использовать диаграммы классов UML. Нотация отражает возможность языка системы CoolKit описывать тип процесса -- формальный параметр функтора прямо в месте описания формального параметра. Вынесение типов параметров в отдельные графические сущности позволяет сделать отношения между процессами -- формальными или фактическими параметрами функторов гораздо более наглядными. Применение функтора изображается так, как показано на рисунке~\ref{functorApplication}.

\begin{figure} [ht]
  \begin{center}
    \includegraphics[width=4cm, keepaspectratio=true]{CoolKitVLmetamodel7.pdf}
    \caption{Примененение функтора}
    \label{functorApplication}
  \end{center}
\end{figure}

Для того, чтобы проиллюстрировать применение диаграммы типов процессов, рассмотрим содержательный пример --- задачу об арбитре динамических приоритетов 4 в 1 из~\cite{coolKit2} . Задача формулируется следующим образом: на один из четырёх входов поступают данные, первый параметр пришедших данных --- приоритет. Если в одном такте данные поступили на несколько входов, на выход выдаются данные с наибольшим приоритетом, остальные входы объявляются неготовыми. Если приходит только одно сообщение, оно отправляется на выход.

Следуя оригинальному решению поступим следующим образом --- сначала напишем арбитр динамических приоритетов 2 в 1 (с двумя входами и одним выходом), затем создадим арбитр-функтор 4 в 1, использующий 3 арбитра 2 в 1, который и решит задачу (~\ref{arbiterProcesses}).

\begin{figure} [ht]
  \begin{center}
    \includegraphics[width=9cm, keepaspectratio=true]{CoolKitVLmetamodel9.pdf}
    \caption{Диаграмма типов процессов для задачи "`Арбитр 4 в 1"'}
    \label{arbiterProcesses}
  \end{center}
\end{figure}

В комментарии --- код процесса DynamicArbiter на языке системы CoolKit, описывающий реализацию арбитра 2 к 1. Код из комментария при синтезе добавляется к сгенерированному описанию процесса, таким образом мы получаем полностью специфицированный арбитр 2 к 1, который может быть использован как фактический параметр функтора Arbiter4to1 (на это указывает отношение генерализации, связывающее DynamicArbiter и безымянный тип процесса --- формальный параметр функтора). Про процесс Arbiter4to1 мы указали пока только то, что он является функтором (готов использовать любой процесс, поддерживающий интерфейс арбитра 2 к 1, который мы определили с помощью безымянного типа процесса), и указали, что у него есть 4 входа и один выход --- то есть просто "нарисовали" условие задачи.

\subsection{Диаграмма отображения портов}

Диаграмма отображения портов рисуется для отдельного процесса и используется для отображения связей между входными и выходными портами вложенных процессов того процесса, для которого рисовалась диаграмма. Таким образом, эта диаграмма фактически является графической нотацией для структурного уровня языка системы CoolKit. Синтаксис с незначительными изменениями совпадает с синтаксисом диаграммы составных структур UML. На диаграмме изображаются процессы и их порты (все порты входов и выходов), связи между портами, внутри процессов могут находиться вложенные процессы. Важно различие между процессом верхнего уровня --- процессом, относительно которого рисуется диаграмма, и вложенными процессами. Вложенные процессы на самом деле являются экземплярами процессов, имеют имя и тип. Процесс верхнего уровня имеет только тип. Пример нотации изображён на рисунке~\ref{portMapProcess}

\begin{figure} [ht]
  \begin{center}
    \includegraphics[width=4cm, keepaspectratio=true]{CoolKitVLmetamodel12.pdf}
    \caption{Процесс на диаграмме отображения портов}
    \label{portMapProcess}
  \end{center}
\end{figure}

Вернёмся к нашему примеру с арбитром 4 к 1. Диаграмма отображения портов для этого примера выглядит так, как показано на рисунке~\ref{arbiter4to1PortMap}.

\begin{figure} [ht]
  \begin{center}
    \includegraphics[width=5cm, keepaspectratio=true]{CoolKitVLmetamodel10.pdf}
    \caption{Диаграмма отображения портов для задачи "`Арбитр 4 в 1"'}
    \label{arbiter4to1PortMap}
  \end{center}
\end{figure}

Здесь мы видим процесс верхнего уровня Arbiter4to1 --- без имени, но с типом и с формальным параметром функтора. Arbiter4to1 имеет 4 входных порта и 1 выходной, их типы здесь уже можно не указывать, они были на диаграмме типов процессов, которую мы нарисовали ранее. Процесс имеет три вложенных процесса A12, A34 и A1234 типа D, который, как следует из диаграммы типов процессов, описывает процессы, имеющие два входа и один выход. Если мы считаем, что в качестве параметра функтора передаётся арбитр 2 к 1, изображённое на рисунке соединение портов решает задачу.

\subsection{Генерация}

Генерация в язык системы CoolKit проходит довольно очевидным образом, поскольку графический и текстовый языки имеют одинаковую модель представления аппаратного устройства. Скелеты описаний процессов генерируются по диаграмме типов процессов, потом они дополняются вложенными процессами и конструкциями, описывающими связь портов по диаграмме отображения портов, потом они дополняются реализацией, которая так или иначе представлена в текстовом виде на диаграмме --- в виде комментария или в виде неотображаемого атрибута процесса. В результате получается полная программа на языке системы CoolKit, готовая к дальнейшей трансляции в VHDL и далее --- в эмулятор или спецификацию устройства.

При генерации считается, что одноимённые однотипные сущности в одном пространстве имён представляют собой одну сущность. То есть, например, если на одной диаграмме описан процесс с одним входом, а на другой диаграмме описан процесс с тем же именем и другим входом, будет сгенерирован один процесс с двумя входами. Такой подход позволяет изображать на каждой диаграмме только существенные для неё части системы, хотя и может привести к некоторой сложности для понимания набора диаграмм в целом. Предполагается, что у средства визуального моделирования существует возможность удобным способом предоставить пользователю информацию о невидимых на диаграмме элементах. Есть некоторые тонкости с тем, что разные формально сущности на разных диаграммах представляют собой одну логическую сущность, например, процесс на диаграмме типов процессов и процесс на диаграмме отображения портов. Такие сущности всё же должны считаться генерацией однотипными и объединяться в одну сущность.

Например, двух ранее приведённых диаграмм, описывающих реализацию арбитра 4 к 1, достаточно, чтобы сгенерировать такой код на языке системы CoolKit:
\begin{verbatim}
process DynamicArbiter =
begin
  in one(uint(2), uint(8));
  in two(uint(2), uint(8));
  out res(uint(8));
  group {
    one(prio1, data1) and prio1 >= prio2,
    two(prio2, data2) and prio1 < prio2
    {
      send res (if prio1 >= prio2 then data1 else data2 fi)
    }
    one(_, ddata) {send res (ddata)}
    two(_, ddata) {send res (ddata)}
  }
end

process Arbiter4to1 (D : begin
                       in one(uint(2), uint(8));
                       in two(uint(2), uint(8));
                       out res(uint(8));
                     end
) =
begin
  in i1 (uint(2), uint(8));
  in i2 (uint(2), uint(8));
  in i3 (uint(2), uint(8));
  in i4 (uint(2), uint(8));
  out res (uint(8));
  process A12 = D with one = i1, two = i2, res = A1234.one;
  process A34 = D with one = i3, two = i4, res = A1234.two;
  process A1234 = D with res = res;
end
\end{verbatim}
Для того, чтобы получить исполнимый код, нужно создать экземпляр процесса Arbiter4to1, использующий в качестве параметра процесс DynamicArbiter. Для этого достаточно нарисовать диаграмму, изображённую на рисунке~\ref{arbiterApply}

\begin{figure} [ht]
  \begin{center}
    \includegraphics[width=3cm, keepaspectratio=true]{CoolKitVLmetamodel11.pdf}
    \caption{Применение функтора "`Арбитр 4 к 1"'}
    \label{arbiterApply}
  \end{center}
\end{figure}

Эта диаграмма породит код \begin{verbatim}process Arbiter = Arbiter4to1(DynamicArbiter);\end{verbatim} который вместе с приведённым ранее кодом может быть синтезирован и исполнен на эмуляторе.

\section*{Заключение}

Пример разработки арбитра 4 к 1, приведённый статье, показал, что графическая нотация оказалась нагляднее и удобнее для разработки, чем текстовая. Предположительно, для более сложных систем графическая нотация даст ещё большую выгоду. Наличие удобных в использовании графических редакторов, генераторов и инструментальных средств, сквозным образом поддерживающих технологию разработки аппаратного обеспечения, от формулировки требований до отладки и тестирования, позволит существенно увеличить продуктивность разработки и повысить надёжность создаваемых устройств. Однако же, в силу большой трудоёмкости создания специализированных графических сред разработки, в силу неудобства существующих редакторов и по ряду других причин визуальное моделирование пока не получило широкого распространения среди разработчиков аппаратного обеспечения. Предложенная в этой статье нотация также ждёт своей реализации в виде удобной среды разработки и генератора, первые шаги для этого уже сделаны в рамках проекта QReal.
Основные результаты, изложенные в статье:

\begin{itemize}
  \item Приведён краткий обзор существующих средств визуального моделирования аппаратного обеспечения, основанных на UML. Наиболее часто для 
        представления аппаратной системы используется три вида диаграмм --- вариации диаграммы классов для моделирования структуры системы, диаграммы 
        составных структур для разбиения системы на подсистемы и описания взаимодействия подсистем, и диаграммы автоматов для задания поведения системы 
        и подсистем. Также важным выводом является то, что имеется тенденция использовать визуальные модели для моделирования одновремменно и 
        программных, и аппаратных частей системы, принимая решение о том, что будет реализовано программно, а что --- аппаратно только в конце процесса 
        разработки.
  \item Предложена графическая нотация для нового текстового языка описания аппаратного обеспечения --- языка системы CoolKit. 
    \begin{itemize}
      \item Предложенный подход предполагает использование текстового языка достаточно высокого уровня как основу графического языка, 
            избавляяразработчиков средств визуального моделирования от сложной задачи генерации низкоуровневого кода по визуальной модели.
      \item Нотация использует текстовые вставки на языке системы CoolKit, тем самым позволяя визуализировать только то, что действительно имеет смысл 
            визуализировать.
      \item На примере предлагаемой нотации показано, что переиспользование модели UML позволяет быстро создать и формально определить визуальный язык 
            для конкретной предметной области.
    \end{itemize}
\end{itemize}

\pagebreak

\begin{thebibliography}{99} 
  \bibitem{coolKit2} {\it Д.Булычев, О.Медведев} CoolKit: проект языка версии 2, 2008г. 
  \bibitem{Uml} {\it Буч Г., Якобсон А., Рамбо Дж.} UML. Классика CS. 2-е изд./Пер. с англ.; Под общей редакцией проф. С. Орлова, СПб., Питер, 2006.
  \bibitem{arnout} {\it Arnout, G} SystemC Standard, Proceedings of the 2000 conference on Asia South Pacific design automation
    Yokohama, Japan, pp 573-578, 2000   
  \bibitem{coolKit1} {\it Boulytchev D.}
    Hardware Description Based on Implicitly Pipelined Signal Handling
  \bibitem{fromUmlToHdl} {\it Coyle F.P., Thornton M.A.} 
    From UML to HDL: a Model Driven Architectural Approach to Hardware-Software Co-Design, 
    http://masters.donntu.edu.ua/2006/fvti/voytenko/library/art09.pdf
  \bibitem{damasevicius1} {\it Damasevicius R., Majauskas G., Stuikys V.} 
    Application of Design Patterns for Hardware Design, Proceedings of the 40th conference on Design automation, pp. 48-53, 2003
  \bibitem{damasevicius2} {\it Damasevicius R., Stuikys V.}
    Application of UML for Hardware Design Based on Design Process Model, asp-dac, pp.244-249, Asia and South Pacific Design Automation Conference 2004
    (ASP-DAC'04), 2004
  \bibitem{riccobene} {\it Riccobene E., Scandurra P., Rosti A. e.a.} A UML 2.0 Profile for SystemC: Toward High-level SoC Design, Proceedings of the  
    5th ACM international conference on Embedded software, Jersey City, NJ, USA, pp 138-141, 2005 
  \bibitem{umlRt} {\it Selic B., Rumbaugh J.} Using UML for Modeling Complex Real-Time Systems, 1998, 
    http://www.dcc.ttu.ee/Automaatika/LAP/ISP0011/umlrt.pdf
  \bibitem{uml1} OMG Unified Modeling Language (OMG UML), Infrastructure, V2.1.2, November 2007, http://www.omg.org/spec/UML/2.1.2/Infrastructure/PDF 
  \bibitem{uml2} OMG Unified Modeling Language (OMG UML), Superstructure, V2.1.2, November 2007, http://www.omg.org/spec/UML/2.1.2/Superstructure/PDF 
\end{thebibliography}

\end{document}
