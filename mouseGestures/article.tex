\documentclass[a5paper]{article}
\usepackage[a5paper, top=17mm, bottom=17mm, left=17mm, right=17mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T2A,T1]{fontenc}
\usepackage[colorlinks,filecolor=blue,citecolor=green,unicode,pdftex]{hyperref}
\usepackage{cmap}
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb,amsfonts,textcomp}
\usepackage{color}
\usepackage{array}
\usepackage{hhline}
\hypersetup{colorlinks=true, linkcolor=blue, citecolor=blue, filecolor=blue, urlcolor=blue, pdftitle=1, pdfauthor=, pdfsubject=, pdfkeywords=}
% \usepackage[pdftex]{graphicx}
\usepackage{graphicx}
\usepackage{epigraph}
% Раскомментировать тем, у кого этот пакет есть. Шрифт станет заметно красивее.
%\usepackage{literat}
\usepackage{indentfirst}

\sloppy
\pagestyle{plain}
%\pagestyle{empty}

\title{Мышиные жесты, ПЫЩЬ}

\author{Т.А. Брыксин \and Ю.В. Литвинов \and М.С. Осечкина}
\date{}
\begin{document}

\maketitle
\thispagestyle{empty}

\epigraph{Цивилизация движется вперед путем увеличения числа операций, которые мы можем осуществлять, не раздумывая над ними}%
         {Альфред Норт Уайтхед}

\begin{quote}
\small\noindent
Аннотация, чо
\end{quote}

\section*{Введение}
Одной из особенностей разработки, управляемой моделями (model-driven development, MDD), является активное использование 
визуальных языков. Практически все действия, выполняемые в CASE-средствах или других используемых инструментах так или 
иначе сводятся к манипуляциям над элементами этих языков и связями между ними. 

Эффективность любого используемого инструмента определяется тем, насколько удобно и быстро он позволяет выполнять те операции, 
для которых этот инструмент предназначен. В процессе разработки моделей одними из наиболее часто выполняемых действий над объектами 
на диаграммах являются их создание и удаление.  В большинстве CASE-средств для того, чтобы создать нужный объект на диаграмме, 
необходимо найти его либо на панели инструментов, либо выбрать в меню, а затем указать место на диаграмме, где бы мы хотели этот 
элемент разместить. В большинстве инструментариев также возможен вариант создания объектов «перетаскиванием» (drag and drop) их из 
палитры элементов соответствующей диаграммы. То есть даже для такой базовой операции, как создание нового элемента, разработчику нужно 
совершить не только набор чисто механических действий, но еще и, скажем, вспомнить, на какой вкладке палитры или в каком меню находится 
нужный ему элемент, тем самым переключая контекст с продумывания иерархии создаваемых моделей на особенности манипуляции 
используемым инструментом. Нам кажется, что данную операцию можно и нужно автоматизировать, причем сделать это нужно максимально удобным для 
пользователей CASE-средств. В данной статье в качестве такого решения рассматривается подход, основанный на жестах мышью. 
Предлагается с каждым элементом ассоциировать определенный жест мышью, выполненный с каким-либо модификатором (скажем, с зажатой 
правой кнопкой мыши или клавишей Alt) и при выполнении этого жеста создавать в данном месте соответствующий объект. 

\section{Постановка задачи}
В качестве CASE-пакета, в котором было решено внедрить и опробовать данный подход, была выбрана система QReal, разрабатываемая на кафедре 
системного программирования СПбГУ. 

Одной из важных особенностей архитектуры QReal является возможность расширения набора графических редакторов. CASE-система состоит из 
некоего ``ядра'', реализующего абстрактную фунциональность редакторов и элементов, создаваемых на диаграммах, и всей необходимой специфики 
конкретных диаграмм, генерящейся из метамоделей соответствующих редакторов (см. рис. 1). Более подробно об архитектуре QReal и предлагаемом 
подходе к  созданию новых визуальных рекдакторов можно прочитать в [1488]. 

[Рис. 1. красивая картинка с архитектурой]

Для данного исследования потенциальная расширяемость QReal означает то, что и предлагаемое решение по встраиванию в среду распознавания
и выполнения команд, соответствующих тем или иным жестам, также не должно зависеть от текущего набора графических редакторов. Так, например,
мы должны иметь возможность задания жеста и ассоциирования его с определенным элементом еще в метамодели, к тому же все необходимые 
для распознавания данные должны автоматически создаваться при генерации исходного кода плагина по метамодели редактора и в идеале не требовать 
никаких дополнительных действий от пользователя. 

\section{Обзор использования жестов в других приложениях}

игры, браузеры, Visual Paradigm и другое с http://ru.wikipedia.org/wiki/Жесты\_мышью

\section{Обзор и выбор алгоритмов распознавания}
Задача компьютерного распознавания образов не нова -- задачи идентификации и классификации предметов решают уже более сорока лет. За это 
время было разработано множество алгоритмов и подходов к решению самых разных задач распознавания, однако независимо от класса 
рассматриваемых задач или предметной области все подходы так или иначе состоят из трех этапов: 
\begin{itemize}
  \item анализ и/или измерение объектов;
  \item выделение их характеристических признаков;
  \item классификация объектов в соответствии с полученными признаками.
\end{itemize}
Чаще всего классификаторы устроены так, что способны работать с векторами произвольных признаков, что дает возможность
проектировать, разрабатывать и тестировать алгоритмы и соответствующие части программного обеспечения независимо друг от друга.
Для жестов мышью наиболее близкой областью является распознавание символов или текста. Основной задачей первого этапа (``измерение'') 
является выделение трактории жеста. Характеристические признаки делятся на две категории:
\begin{itemize}
  \item Динамические признаки, итеративно получающиеся в процессе построения траектории жеста в зависимости от скорости или положения
появляющихся участков жеста во времени.
  \item Статические признаки, которые выделяются уже после того, как жест завершен и траектория уже получена.
\end{itemize}
В случае создания элементов на диаграмме жест имеет смысл распознавать и обрабатывать только после того, как он завершен, поэтому
для решения данной задачи было решено использовать статические характеристики траектории. 

Среди способов формирования статических признаков наиболее распространенными и оптимальными в соотношении надежность/простота в реализации и 
применении, на наш взгляд, являются алгоритмы, сопоставляющие траектории жеста строку из некоторого алфавита. 

При выборе характеристик наиболее очевидным подходом является рассматривать изменения направления участков жеста, каждому из таких направлений соответствует угол на плоскости и символ в 
алфавите, путь мыши при этом представляется как последовательность направлений (направление определяется принадлежностью одному из диапазонов 
углов). Недостаток этого алгоритма состоит в том, что при недостаточной фильтрации легко перепутать объекты. Длины отрезков в пути мыши не учитываются, 
то есть даже небольшое дрожание руки, породившее короткий отрезок в неправильном направлении, может привести к ложному распознаванию жеста.

Тут будет кусок про выбор алгоритмов построения строки.

Есть еще куча всяких фич с сотнями матана в них, но там Тимофей заснул на третьей формуле, так что мы их, пожалуй, пропустим.

Среди используемых подходов к классификации наибольшей популярностью в подобного рода задачах является использование таких математических моделей как 
искусственные нейронные сети ([n,m,k]), скрытые марковские модели ([i,j]), а также других классификаторов, получаемых обучением с помощью, например, метода
опорных векторов ([p,q]) или алгоритмов AdaBoost/FloatBoost ([x,y,z]). Основным недостатком всех этих подходов с точки зрения решаемой нами задачи является
то, что все они предполагают наличие этапа обучения классификатора, что влечет за собой во-первых требование наличия большой базы примеров (например, набора 
типичных траекторий для каждого жеста), а во-вторых, процесс обучения чаще всего весьма затратный как по времени, так и по вычислительным ресурсам. 
Каждое из этих последствий делает использование подобного рода алгоритмов для нас невозможным, потому как подключение новых редакторов (а, следовательно, и 
новых жестов для каждого из элементов) должно происходить в реальном времени без каких-либо дополнительных действий со стороны пользователя и не требовать 
никаких дополнительных машинных ресурсов. 

Другим часто используемым в машинном обучении подходом к классификации объектов является так называемая задача поиска ближайшего соседа [12, 34], заключающийся
в отыскании среди множества элементов, расположенных в неком метрическом пространстве (в общем случае, многомерном), элементов близких к заданному, согласно 
некоторой функции близости. В случае представления траекторий строками из некоторого алфавита в качестве функции близости можно взять расстояние Левенштейна.




\section{Реализация}

\section{Направления дальнейшего исследования}

\end{document}






