\documentclass[a5paper]{article}
\usepackage[a5paper, top=17mm, bottom=17mm, left=17mm, right=17mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T2A,T1]{fontenc}
\usepackage[colorlinks,filecolor=blue,citecolor=green,unicode,pdftex]{hyperref}
\usepackage{cmap}
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb,amsfonts,textcomp}
\usepackage{color}
\usepackage{array}
\usepackage{hhline}
\hypersetup{colorlinks=true, linkcolor=blue, citecolor=blue, filecolor=blue, urlcolor=blue, pdftitle=1, pdfauthor=, pdfsubject=, pdfkeywords=}
% \usepackage[pdftex]{graphicx}
\usepackage{graphicx}
\usepackage{epigraph}
% Раскомментировать тем, у кого этот пакет есть. Шрифт станет заметно красивее.
%\usepackage{literat}
\usepackage{indentfirst}

\sloppy
\pagestyle{plain}
%\pagestyle{empty}

\title{Мышиные жесты, ПЫЩЬ}

\author{Т.А. Брыксин \and Ю.В. Литвинов \and М.С. Осечкина}
\date{}
\begin{document}

\maketitle
\thispagestyle{empty}

\epigraph{Цивилизация движется вперед путем увеличения числа операций, которые мы можем осуществлять, не раздумывая над ними}%
         {Альфред Норт Уайтхед}

\begin{quote}
\small\noindent
Аннотация, чо
\end{quote}

\section*{Введение}
Одной из особенностей разработки, управляемой моделями (model-driven development, MDD), является активное использование 
визуальных языков. Практически все действия, выполняемые в CASE-средствах или других используемых инструментах так или 
иначе сводятся к манипуляциям над элементами этих языков и связями между ними. 

Эффективность любого используемого инструмента определяется тем, насколько удобно и быстро он позволяет выполнять те операции, 
для которых этот инструмент предназначен. В процессе разработки моделей одними из наиболее часто выполняемых действий над объектами 
на диаграммах являются их создание и удаление.  В большинстве CASE-средств для того, чтобы создать нужный объект на диаграмме, 
необходимо найти его либо на панели инструментов, либо выбрать в меню, а затем указать место на диаграмме, где бы мы хотели этот 
элемент разместить. В большинстве инструментариев также возможен вариант создания объектов «перетаскиванием» (drag and drop) их из 
палитры элементов соответствующей диаграммы. То есть даже для такой базовой операции, как создание нового элемента, разработчику нужно 
совершить не только набор чисто механических действий, но еще и, скажем, вспомнить, на какой вкладке палитры или в каком меню находится 
нужный ему элемент, тем самым переключая контекст с продумывания иерархии создаваемых моделей на особенности манипуляции 
используемым инструментом. Нам кажется, что данную операцию можно и нужно автоматизировать, причем сделать это нужно максимально удобным для 
пользователей CASE-средств. В данной статье в качестве такого решения рассматривается подход, основанный на жестах мышью. 
Предлагается с каждым элементом ассоциировать определенный жест мышью, выполненный с каким-либо модификатором (скажем, с зажатой 
правой кнопкой мыши или клавишей Alt) и при выполнении этого жеста создавать в данном месте соответствующий объект. 

\section{Постановка задачи}
В качестве CASE-пакета, в котором было решено внедрить и опробовать данный подход, была выбрана система QReal, разрабатываемая на кафедре 
системного программирования СПбГУ. 

Одной из важных особенностей архитектуры QReal является возможность расширения набора графических редакторов. CASE-система состоит из 
некоего ``ядра'', реализующего абстрактную фунциональность редакторов и элементов, создаваемых на диаграммах, и всей необходимой специфики 
конкретных диаграмм, генерящейся из метамоделей соответствующих редакторов (см. рис. 1). Более подробно об архитектуре QReal и предлагаемом 
подходе к  созданию новых визуальных рекдакторов можно прочитать в [1488]. 

[Рис. 1. красивая картинка с архитектурой]

Для данного исследования потенциальная расширяемость QReal означает в первую очередь то, что и предлагаемое решение по встраиванию в среду 
распознавания и выполнения команд, соответствующих тем или иным жестам, также не должно зависеть от текущего набора графических редакторов. 
Так, например, мы должны иметь возможность задания жеста и ассоциирования его с определенным элементом еще в метамодели, к тому же все 
необходимые для распознавания данные должны автоматически создаваться при генерации исходного кода плагина по метамодели редактора и в 
идеале не требовать никаких дополнительных действий от пользователя (за иключением случаев, если пользователь хочет отключить какой-либо 
жест или его подправить).

Помимо этого, предлагаемое решение должно обеспечивать простоту генерируемых жестов. Нарисовать жест мышью должно быть проще и быстрее, 
чем выполнить традиционные для многих CASE-пакетов операции по созданию объекта, описанные выше. 

Большинство элементов в визуальных языках имеют представления на диаграммах, состоящие из довольно небольшого набора базовых графических 
притивов: эллипсов, прямоугольников, линий и их сочетания. Для таких несложных элементов было бы логично потребовать, чтобы жест, 
соответствующий их созданию, визуально напоминал графическое представление данного объекта. Это позволило бы пользователю CASE-системы 
сэкономить время и силы на запоминание большого числа жестов и сделало бы процесс их использование более естественным. 


\section{Обзор использования жестов в других приложениях}

игры, браузеры, Visual Paradigm и другое с http://ru.wikipedia.org/wiki/Жесты\_мышью

\section{Обзор и выбор алгоритмов распознавания}
Задача компьютерного распознавания образов не нова -- задачи идентификации и классификации предметов решают уже более сорока лет. За это 
время было разработано множество алгоритмов и подходов к решению самых разных задач распознавания, однако независимо от класса 
рассматриваемых задач или предметной области все подходы так или иначе состоят из трех этапов: 
\begin{itemize}
  \item анализ и/или измерение объектов;
  \item выделение их характеристических признаков;
  \item классификация объектов в соответствии с полученными признаками.
\end{itemize}

\subsection{Этап измерения}
Для жестов мышью наиболее близкой областью является распознавание одиночных символов или текста в целом. Основной задачей первого этапа 
(``измерение'') является выделение трактории жеста. Применительно к решаемой задаче построение траектории сводится к отслеживанию 
перемещения координат курсора мыши, что не представляет сложностей в реализации. 

\subsection{Классификаторы}

Чаще всего классификаторы устроены так, что способны работать с векторами произвольных признаков, что дает возможность
проектировать, разрабатывать и тестировать алгоритмы и соответствующие части программного обеспечения независимо друг от друга. Однако, 
выбор подходящего классификатора и соотвествующий анализ предметной области и требований к решению, который этому выбору сопутствует, 
может прояснить и уточнить некоторые вопросы, связанные и с выбором и выделением признаков. 

Среди используемых подходов к классификации наибольшей популярностью в задачах распознавания как одиночных символов, так и текста является 
использование таких математических моделей как искусственные нейронные сети ([n,m,k]), скрытые марковские модели ([i,j]), а также других 
классификаторов, получаемых обучением с помощью, например, метода опорных векторов ([p,q]) или алгоритмов AdaBoost/FloatBoost ([x,y,z]). 
Основным недостатком всех этих подходов с точки зрения решаемой нами задачи является то, что все они предполагают наличие выделенного этапа 
обучения классификатора, что влечет за собой во-первых требование наличия большой базы примеров (например, набора 
типичных траекторий для каждого жеста), а во-вторых, процесс обучения чаще всего весьма затратный как по времени, так и по вычислительным 
ресурсам. Каждая из этих особенностей делает использование подобного рода алгоритмов для нас невозможным, потому как подключение новых 
редакторов (а, следовательно, и новых жестов для каждого из элементов) должно происходить в реальном времени без каких-либо дополнительных 
действий со стороны пользователя и не требовать никаких дополнительных машинных ресурсов. 

Другим часто используемым в машинном обучении подходом к классификации объектов является так называемая задача поиска ближайшего соседа 
[12, 34], заключающийся в отыскании среди множества элементов, расположенных в некоем метрическом пространстве (в общем случае, многомерном), 
элементов, близких к заданному, согласно некоторой функции близости. В нашем случае каждому жесту соответствует траектория движения курсора 
мыши -- список точек. Однако, предпочтительнее было бы иметь дело с более простыми 
объектами, чем списки точек. К примеру, при переносе траектории мыши должен генерироваться один и тот же объект, но координаты точек 
тракетории могут измениться довольно сильно. Для обработки этой ситуации можно переносить жест в начало координат, но тогда возникает проблема
масштабирования -- подобным жестам разного размера должен соответствовать один и тот же объект. Можно приводить жест к заранее 
заданному размеру, но это может повлиять на распознавание объекта.

Таким образом, при работе с пространством точек даже после переноса и масштабирования довольно сложно понять, на какой из жестов 
больше похожа та или иная траектория. Некоторые существующие реализации предлагают следующее решение проблемы: сопоставим каждому жесту 
ключ-строку и будем сравнивать не списки точек таектории жестов, а ключи, им соответствуюшие. Тогда в случае представления траекторий 
строками из некоторого алфавита в качестве функции близости можно взять расстояние Левенштейна 
между этими строками, которое определяется как минимальное количество операций вставки одного символа, удаления одного символа и замены 
одного символа на другой для превращения одной строки в другую [88]. Расстояние Левенштейна обладает некоторыми известными недостатками:
\begin{itemize}
  \item При перестановке местами слов или частей слов получаются большие расстояния.
  \item Расстояния между совершенно разными короткими строками оказываются небольшими, а расстояния между похожими длинными словами 
оказываются значительными.
\end{itemize}
Если первый недостаток критичен скорее при исправлении ошибок в слове и не важен в нашем случае, то из-за второго пункта сложному 
жесту может быть сопоставлен неверный объект. Для того, чтобы избежать неверной интерпретации жеста, будем сравнивать не само расстояние, 
а соотношение 

\begin{equation}
\label{levenshtein}
d_{normalized}(s1,s2) = \frac{d(s1,s2)}{min(s1,s2)},
\end{equation}

где d(s1,s2) -- расстояние Левенштейна между строками s1 и s2, а min(s1,s2) -- что-то еще. [пояснить]

Прежде чем заниматься алгоритмом распознавания, необходимо определить, какой жест будет соответствовать тому или иному объекту. Для каждого 
объекта зададим идеальный жест -- эталон, с которым сравниваются нарисованные пользователем жесты. Каждому объекту соответствует ровно один 
идеальный жест, который, исходя из требований к решению, будем генерировать на основе графического представления этого элемента. 




\subsection{Выделение признаков}
Характеристические признаки в свою очередь делятся на две категории: [убрать?]
\begin{itemize}
  \item Динамические признаки, итеративно получающиеся в процессе построения траектории жеста, чаще всего в зависимости от скорости или 
положения появляющихся участков жеста во времени.
  \item Статические признаки, которые выделяются уже после того, как жест завершен и его траектория уже получена.
\end{itemize}
В случае создания элементов на диаграмме жест имеет смысл распознавать и обрабатывать только после того, как он завершен, поэтому
для решения данной задачи было решено сосредоточить внимание на статических характеристиках траектории. 

Исходя из выбора классификатора и строкового рабочего пространства, рассмотрим алгоритмы, сопоставляющие траектории жеста строку из 
некоторого алфавита. Наиболее очевидным подходом здесь является отслеживание изменений ориентации участков жеста относительно некоторой 
системы координат. Каждому из таких направлений соответствует угол на плоскости, который попадает в 
один из диапазонов, а каждому из диапазонов углов ставится в соответствие символ в алфавите (см. рис. 2). 

[Рис. 2. Хаосистские звезды]

Путь мыши при этом представляется как последовательность символов, соответствующих каждому из направлений, получающаяся после удаления 
повторяющихся подряд идущих символов. Недостаток этого алгоритма состоит в том, что при недостаточной фильтрации легко перепутать объекты 
[тут надо пояснить]. Длины отрезков в пути мыши не учитываются, то есть даже небольшое дрожание руки, породившее короткий отрезок в 
неправильном направлении, может привести к ложному распознаванию жеста. [а если учитывать?]

Другой алгоритм предлагает рассматривать не принадлежность направлению, а принадлежность прямоугольнику. Вокруг траектории законченного жеста 
описывается прямоугольник, каждая сторона которого делится горизонтальными и вертикальными прямыми на 8 частей (см. рис. 3). Каждому внутреннему 
прямоугольнику ставим в соответствие символ алфавита. Строка-ключ жеста будет состоять из символов, соответствующих прямоугольникам, по
которым проходит трактория жеста. После удаления подряд идущих одинаковых символов из строки получаем окончательный ключ текущего жеста. 

[Рис. 3. Красивая картинка с гламурным розово-фиолетовым прямоугольником]

Этот алгоритм хорош тем, что при его использовании не надо масштабировать жест. Очевидно, что подобным фигурам действительно соответствуют 
одни и те же ключи.

Подряд идущие повторяющиеся символы можно не удалять, но тогда жест придется масштабировать -- приводить к 
заранее определенному стандартному размеру. В этом случае возникает проблема с кривыми, которые не подобны, но соответствуют одному и 
тому же объекту [пояснить]: при уменьшении фигуры важные звенья ломанной могут перейти в слишком маленькие, которые при фильтрации должны исчезнуть.
Можно выбрать алгоритм генерации ключа, чувствительный к малейшим изменениям движения и учитывающий короткие отрезки в пути мыши. Но
тогда, несмотря на фильтрацию, одному и тому же объекту будет соответствовать очень большое число возможных жестов, некоторые из
которых будут мало похожи друг на друга, что сильно усложнит этап классификации.

[тут видимо вкратце про веса?]

\subsection{Фильтрация}

\subsection{Алгоритм распознавания жестов без генерации строки-ключа}

При создании QReal использовуется инструментарий Qt, где уже есть реализация поддержки жестов мышью. Рассмотрим алгоритм предложенный 
разработчиками Qt [321].

Шаги алгоритма:
\begin{enumerate}
  \item Фильтрация пути мыши.
  \item Сопоставление объекта из списка. Предполагается, что объект в этом алгоритме — это ломаная (в нашем случае идеальный граф)
  \begin{enumerate}
    \item Приближение направлениями. На этом этапе каждый сегмент ломаной приближается одним из заранее определенных базовых направлений. 
Как правило, их 4 – вверх, вниз, вправо, влево. Для большей точности количество базовых направлений можно увеличить, при этом удобно 
брать число, кратное 4, чтобы 4 базовых направления оставались неизменными, и каждое было биссектрисой двух соседних. При увеличении числа 
направлений к жестам можно добавлять сложные многоугольники, стороны которых не обязательно параллельны осям координат, которые было бы 
невозможно распознать в случае использования только четырех направлений.
    \item Упрощение списка направлений, заключающееся в том, чтобы найти подряд идущие соноправленные вектора и объединить их в 
один вектор, просуммировав длину.
    \item Сопоставление и удаление. Эта часть алгоритма является, пожалуй, наиболее сложной, так как, несмотря на фильтрацию, останутся 
мелкие сбои вдоль длинных отрезков. На этом шаге списку направлений сопоставляется команда. Если для списка нет команды, мы удаляем 
кратчайший отрезок и повторяем попытку. Алгоритм заканчивается, если удалось получить команду, или большая часть первоначального списка 
направлений была удалена.
  \end{enumerate}
\end{enumerate}

Недостаток этого алгоритма состоит в том, что изменение оставшихся отрезков после удаления самого короткого довольно нетривиально. 
Чтобы путь не потерял связность, удалить отрезок, не изменив концы соседних с ним, невозможно. Чтобы отрезки сохранили свое направление, 
придется менять не только соседние. Например, на рис. 4a показана часть пути мыши. После удаления самого короткого отрезка с номером 2, 
переносим отрезок номер 3, тем самым меняя координаты начала отрезка номер 4. Путь преобразуется в траекторию, приведенную на рис. 4b.
Стоит заметить, что при увеличении числа направлений перестраивать путь будет все сложнее. 

[Рис. 4. Картинк с кутешным алгоритмом]

\subsection{Предлагаемый подход}

Исходя из рассмотренных алгоритмов распознавания, а также в соответствии со спецификой задачи был выбран следующий подход к ее решению:

\begin{itemize}
  \item CASE-система получает сигналы о том, что пользователь зажал правую кнопку мыши и перемещает курсор, и сохраняет координаты положения курсора
через равные промежутки времени. Жест считается завершенным, когда пользователь отпускает кнопку мыши.
  \item Осуществляется сглаживание полученной траектории. Этот шаг необходим, так как различное оборудование дает разную точность при получении 
позиции курсора. Кроме того, если учитывать все дрожания руки, придется усложнять следующий шаг -- сопоставление объекта: каждому объекту
будет соответствовать слишком много разных вариантов пути мыши.
  \item Списку точек сопоставляется строка в соответствии с алгоритмом, отраженным на рис. 3. [может его как-то поименовать?]
  \item С помощью модифицированного алгоритма Левенштейна находится идеальный ключ, расстояние $d_{normalized}$ ~(\ref{levenshtein}) между которым и 
сгенерированным по нарисованному жесту наименьшее. Если ключ достаточно близок к идеальному, на диаграмме создается объект, соответствующий этому ключу.
\end{itemize}


\section{Реализация}

\section{Направления дальнейшего исследования}

\end{document}






